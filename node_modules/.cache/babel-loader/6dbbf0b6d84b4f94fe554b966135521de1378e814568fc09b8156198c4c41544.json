{"ast":null,"code":"import _objectWithoutProperties from \"/Users/rizzytwizzy/Projects/gam3/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"args\", \"cellColor\", \"sectionColor\", \"cellSize\", \"sectionSize\", \"followCamera\", \"infiniteGrid\", \"fadeDistance\", \"fadeStrength\", \"cellThickness\", \"sectionThickness\", \"side\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport mergeRefs from 'react-merge-refs';\nimport { extend, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nvar GridMaterial = shaderMaterial({\n  cellSize: 0.5,\n  sectionSize: 1,\n  fadeDistance: 100,\n  fadeStrength: 1,\n  cellThickness: 0.5,\n  sectionThickness: 1,\n  cellColor: new THREE.Color(),\n  sectionColor: new THREE.Color(),\n  infiniteGrid: false,\n  followCamera: false,\n  worldCamProjPosition: new THREE.Vector3(),\n  worldPlanePosition: new THREE.Vector3()\n}, /* glsl */\"\\n    varying vec3 localPosition;\\n    varying vec4 worldPosition;\\n\\n    uniform vec3 worldCamProjPosition;\\n    uniform vec3 worldPlanePosition;\\n    uniform float fadeDistance;\\n    uniform bool infiniteGrid;\\n    uniform bool followCamera;\\n\\n    void main() {\\n      localPosition = position.xzy;\\n      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;\\n      \\n      worldPosition = modelMatrix * vec4(localPosition, 1.0);\\n      if (followCamera) {\\n        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);\\n        localPosition = (inverse(modelMatrix) * worldPosition).xyz;\\n      }\\n\\n      gl_Position = projectionMatrix * viewMatrix * worldPosition;\\n    }\\n  \", /* glsl */\"\\n    varying vec3 localPosition;\\n    varying vec4 worldPosition;\\n\\n    uniform vec3 worldCamProjPosition;\\n    uniform float cellSize;\\n    uniform float sectionSize;\\n    uniform vec3 cellColor;\\n    uniform vec3 sectionColor;\\n    uniform float fadeDistance;\\n    uniform float fadeStrength;\\n    uniform float cellThickness;\\n    uniform float sectionThickness;\\n\\n    float getGrid(float size, float thickness) {\\n      vec2 r = localPosition.xz / size;\\n      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\\n      float line = min(grid.x, grid.y) + 1.0 - thickness;\\n      return 1.0 - min(line, 1.0);\\n    }\\n\\n    void main() {\\n      float g1 = getGrid(cellSize, cellThickness);\\n      float g2 = getGrid(sectionSize, sectionThickness);\\n\\n      float dist = distance(worldCamProjPosition, worldPosition.xyz);\\n      float d = 1.0 - min(dist / fadeDistance, 1.0);\\n      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));\\n\\n      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));\\n      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\\n      if (gl_FragColor.a <= 0.0) discard;\\n\\n      #include <tonemapping_fragment>\\n      #include <encodings_fragment>\\n    }\\n  \");\nvar Grid = /*#__PURE__*/React.forwardRef(function (_ref, fRef) {\n  var args = _ref.args,\n    _ref$cellColor = _ref.cellColor,\n    cellColor = _ref$cellColor === void 0 ? '#000000' : _ref$cellColor,\n    _ref$sectionColor = _ref.sectionColor,\n    sectionColor = _ref$sectionColor === void 0 ? '#2080ff' : _ref$sectionColor,\n    _ref$cellSize = _ref.cellSize,\n    cellSize = _ref$cellSize === void 0 ? 0.5 : _ref$cellSize,\n    _ref$sectionSize = _ref.sectionSize,\n    sectionSize = _ref$sectionSize === void 0 ? 1 : _ref$sectionSize,\n    _ref$followCamera = _ref.followCamera,\n    followCamera = _ref$followCamera === void 0 ? false : _ref$followCamera,\n    _ref$infiniteGrid = _ref.infiniteGrid,\n    infiniteGrid = _ref$infiniteGrid === void 0 ? false : _ref$infiniteGrid,\n    _ref$fadeDistance = _ref.fadeDistance,\n    fadeDistance = _ref$fadeDistance === void 0 ? 100 : _ref$fadeDistance,\n    _ref$fadeStrength = _ref.fadeStrength,\n    fadeStrength = _ref$fadeStrength === void 0 ? 1 : _ref$fadeStrength,\n    _ref$cellThickness = _ref.cellThickness,\n    cellThickness = _ref$cellThickness === void 0 ? 0.5 : _ref$cellThickness,\n    _ref$sectionThickness = _ref.sectionThickness,\n    sectionThickness = _ref$sectionThickness === void 0 ? 1 : _ref$sectionThickness,\n    _ref$side = _ref.side,\n    side = _ref$side === void 0 ? THREE.BackSide : _ref$side,\n    props = _objectWithoutProperties(_ref, _excluded);\n  extend({\n    GridMaterial: GridMaterial\n  });\n  var ref = React.useRef(null);\n  useFrame(function (state) {\n    var plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0)).applyMatrix4(ref.current.matrixWorld);\n    var gridMaterial = ref.current.material;\n    var worldCamProjPosition = gridMaterial.uniforms.worldCamProjPosition;\n    var worldPlanePosition = gridMaterial.uniforms.worldPlanePosition;\n    plane.projectPoint(state.camera.position, worldCamProjPosition.value);\n    worldPlanePosition.value.set(0, 0, 0).applyMatrix4(ref.current.matrixWorld);\n  });\n  var uniforms1 = {\n    cellSize: cellSize,\n    sectionSize: sectionSize,\n    cellColor: cellColor,\n    sectionColor: sectionColor,\n    cellThickness: cellThickness,\n    sectionThickness: sectionThickness\n  };\n  var uniforms2 = {\n    fadeDistance: fadeDistance,\n    fadeStrength: fadeStrength,\n    infiniteGrid: infiniteGrid,\n    followCamera: followCamera\n  };\n  return /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: mergeRefs([ref, fRef]),\n    frustumCulled: false\n  }, props), /*#__PURE__*/React.createElement(\"gridMaterial\", _extends({\n    transparent: true,\n    \"extensions-derivatives\": true,\n    side: side\n  }, uniforms1, uniforms2)), /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: args\n  }));\n});\nexport { Grid };","map":{"version":3,"names":["_extends","React","THREE","mergeRefs","extend","useFrame","shaderMaterial","GridMaterial","cellSize","sectionSize","fadeDistance","fadeStrength","cellThickness","sectionThickness","cellColor","Color","sectionColor","infiniteGrid","followCamera","worldCamProjPosition","Vector3","worldPlanePosition","Grid","forwardRef","_ref","fRef","args","_ref$cellColor","_ref$sectionColor","_ref$cellSize","_ref$sectionSize","_ref$followCamera","_ref$infiniteGrid","_ref$fadeDistance","_ref$fadeStrength","_ref$cellThickness","_ref$sectionThickness","_ref$side","side","BackSide","props","_objectWithoutProperties","_excluded","ref","useRef","state","plane","Plane","setFromNormalAndCoplanarPoint","applyMatrix4","current","matrixWorld","gridMaterial","material","uniforms","projectPoint","camera","position","value","set","uniforms1","uniforms2","createElement","frustumCulled","transparent"],"sources":["/Users/rizzytwizzy/Projects/gam3/node_modules/@react-three/drei/core/Grid.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport mergeRefs from 'react-merge-refs';\nimport { extend, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\n\nconst GridMaterial = shaderMaterial({\n  cellSize: 0.5,\n  sectionSize: 1,\n  fadeDistance: 100,\n  fadeStrength: 1,\n  cellThickness: 0.5,\n  sectionThickness: 1,\n  cellColor: new THREE.Color(),\n  sectionColor: new THREE.Color(),\n  infiniteGrid: false,\n  followCamera: false,\n  worldCamProjPosition: new THREE.Vector3(),\n  worldPlanePosition: new THREE.Vector3()\n},\n/* glsl */\n`\n    varying vec3 localPosition;\n    varying vec4 worldPosition;\n\n    uniform vec3 worldCamProjPosition;\n    uniform vec3 worldPlanePosition;\n    uniform float fadeDistance;\n    uniform bool infiniteGrid;\n    uniform bool followCamera;\n\n    void main() {\n      localPosition = position.xzy;\n      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;\n      \n      worldPosition = modelMatrix * vec4(localPosition, 1.0);\n      if (followCamera) {\n        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);\n        localPosition = (inverse(modelMatrix) * worldPosition).xyz;\n      }\n\n      gl_Position = projectionMatrix * viewMatrix * worldPosition;\n    }\n  `,\n/* glsl */\n`\n    varying vec3 localPosition;\n    varying vec4 worldPosition;\n\n    uniform vec3 worldCamProjPosition;\n    uniform float cellSize;\n    uniform float sectionSize;\n    uniform vec3 cellColor;\n    uniform vec3 sectionColor;\n    uniform float fadeDistance;\n    uniform float fadeStrength;\n    uniform float cellThickness;\n    uniform float sectionThickness;\n\n    float getGrid(float size, float thickness) {\n      vec2 r = localPosition.xz / size;\n      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n      float line = min(grid.x, grid.y) + 1.0 - thickness;\n      return 1.0 - min(line, 1.0);\n    }\n\n    void main() {\n      float g1 = getGrid(cellSize, cellThickness);\n      float g2 = getGrid(sectionSize, sectionThickness);\n\n      float dist = distance(worldCamProjPosition, worldPosition.xyz);\n      float d = 1.0 - min(dist / fadeDistance, 1.0);\n      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));\n\n      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));\n      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\n      if (gl_FragColor.a <= 0.0) discard;\n\n      #include <tonemapping_fragment>\n      #include <encodings_fragment>\n    }\n  `);\nconst Grid = /*#__PURE__*/React.forwardRef(({\n  args,\n  cellColor = '#000000',\n  sectionColor = '#2080ff',\n  cellSize = 0.5,\n  sectionSize = 1,\n  followCamera = false,\n  infiniteGrid = false,\n  fadeDistance = 100,\n  fadeStrength = 1,\n  cellThickness = 0.5,\n  sectionThickness = 1,\n  side = THREE.BackSide,\n  ...props\n}, fRef) => {\n  extend({\n    GridMaterial\n  });\n  const ref = React.useRef(null);\n  useFrame(state => {\n    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0)).applyMatrix4(ref.current.matrixWorld);\n    const gridMaterial = ref.current.material;\n    const worldCamProjPosition = gridMaterial.uniforms.worldCamProjPosition;\n    const worldPlanePosition = gridMaterial.uniforms.worldPlanePosition;\n    plane.projectPoint(state.camera.position, worldCamProjPosition.value);\n    worldPlanePosition.value.set(0, 0, 0).applyMatrix4(ref.current.matrixWorld);\n  });\n  const uniforms1 = {\n    cellSize,\n    sectionSize,\n    cellColor,\n    sectionColor,\n    cellThickness,\n    sectionThickness\n  };\n  const uniforms2 = {\n    fadeDistance,\n    fadeStrength,\n    infiniteGrid,\n    followCamera\n  };\n  return /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: mergeRefs([ref, fRef]),\n    frustumCulled: false\n  }, props), /*#__PURE__*/React.createElement(\"gridMaterial\", _extends({\n    transparent: true,\n    \"extensions-derivatives\": true,\n    side: side\n  }, uniforms1, uniforms2)), /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: args\n  }));\n});\n\nexport { Grid };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}